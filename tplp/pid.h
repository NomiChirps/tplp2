#ifndef TPLP_PID_H_
#define TPLP_PID_H_

#include "picolog/picolog.h"
#include "tplp/config/params.h"
#include "tplp/numbers.h"
#include "tplp/util.h"

namespace tplp {

class DerivativeEstimator {
 public:
  explicit DerivativeEstimator(int32_t x0) : x_(x0) {}

  // returns derivative times 6, so we don't have to divide here
  int32_t value() const {
    // formula generated by https://web.media.mit.edu/~crtaylor/calculator.html
    return -2 * x_[3] + 9 * x_[2] - 18 * x_[1] + 11 * x_[0];
  }

  // pushes new x[0] and returns value()
  int32_t Update(int32_t xn) {
    x_.push_front(xn);
    return value();
  }

 private:
  RingBuffer<int32_t, 4> x_;
};

// PID controller.

template <int FracBits>
struct PIDParams {
  using param_t = config::Parameter<fix32_t<FracBits>>;
  param_t* P;
  param_t* I;
  param_t* D;
  param_t* I_deadband;
  param_t* I_liveband;
};

template <int FracBits, PIDParams<FracBits> params>
class PID {
 public:
  explicit PID(const char* name, int32_t initial_output)
      : name_(name),
        output(initial_output, 0),
        d0(0, 0),
        d1(0, 0),
        fd0(0, 0),
        fd1(0, 0) {
    error_[0] = 0;
    error_[1] = 0;
    error_[2] = 0;
    pv_[0] = 0;
    pv_[1] = 0;
    pv_[2] = 0;
  }

  // Runs a loop iteration. Returns the PID output.
  // sp: setpoint,
  // pv: process variable,
  // dt: timestep since last update
  int32_t Update(int32_t sp, int32_t pv, int32_t dt);

 private:
  const char* const name_;

  int32_t error_[3];
  int32_t pv_[3];
  fix32_t<FracBits> output;
  fix32_t<FracBits> d0;
  fix32_t<FracBits> d1;
  fix32_t<FracBits> fd0;
  fix32_t<FracBits> fd1;

  // int32_t integral_;
  // DerivativeEstimator derivative_;

  // int32_t last_error_;
};

template <int FracBits, PIDParams<FracBits> params>
int32_t PID<FracBits, params>::Update(int32_t sp, int32_t pv, int32_t dt) {
  auto Kp = params.P->Get();
  auto Ki = params.I->Get();
  auto Kd = params.D->Get();
  auto A0 = Kp + Ki * dt;
  auto A1 = -Kp;
  auto A0d = Kd / dt;
  auto A1d = -2 * Kd / dt;
  auto A2d = Kd / dt;
  auto N = 5;
  auto tau = Kd / (Kp * N);  // IIR filter time constant
  auto alpha = dt / (2 * tau);

  error_[2] = error_[1];
  error_[1] = error_[0];
  error_[0] = sp - pv;
  pv_[2] = pv_[1];
  pv_[1] = pv_[0];
  pv_[0] = pv;
  // PI
  auto PI = A0 * error_[0] + A1 * error_[1];
  output += PI;
  // Filtered D
  d1 = d0;
  d0 = A0d * pv_[0] + A1d * pv_[1] + A2d * pv_[2];
  fd1 = fd0;
  fd0 = ((alpha) / (alpha + 1)) * (d0 + d1) - ((alpha - 1) / (alpha + 1)) * fd1;
  output += fd0;

  // TODO: reset I outside of liveband
  // TODO: don't accumulate I inside of deadband

  VLOG(1) << name_ << " sp=" << sp << " pv=" << pv << " PI=" << PI
          << " D=" << fd0 << "; error = " << error_[0] << " op = " << output;
  return output.round();
}

}  // namespace tplp

#endif  // TPLP_PID_H_