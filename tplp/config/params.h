#ifndef TPLP_CONFIG_PARAMS_H_
#define TPLP_CONFIG_PARAMS_H_

#include <functional>

#include "absl/strings/str_cat.h"
#include "picolog/picolog.h"
#include "picolog/status.h"
#include "picolog/statusor.h"
#include "tplp/numbers.h"

// Defines a persistent parameter. It contains a default value until
// Load() or LoadAllParameters() is used.
#define TPLP_PARAM(Type, name, default_value, help)    \
  extern ::tplp::config::Parameter<Type> PARAM_##name; \
  namespace tplp {}                                    \
  tplp::config::Parameter<Type> PARAM_##name {         \
#name, default_value, help                         \
  }

// Declares a persistent parameter which is defined in another module.
#define TPLP_DECLARE_PARAM(Type, name) \
  extern ::tplp::config::Parameter<Type> PARAM_##name;

namespace tplp {
namespace config {

static constexpr int kMaxNumParams = 32;

// If non-OK, there was an error during static initialization.
const util::Status& DeferredInitError();

class ParameterBase {
 public:
  ParameterBase(const ParameterBase&) = delete;
  ParameterBase& operator=(const ParameterBase&) = delete;
  virtual ~ParameterBase();

  // Sets this parameter's value from a string representation, which should have
  // been previously generated by Serialize().
  virtual util::Status Parse(std::string_view str) = 0;

  // Writes a string representation of this parameter's value into the given
  // buffer. Returns the number of bytes written, which shall be at most `n`.
  // No trailing NULL is appended.
  virtual util::StatusOr<size_t> Serialize(char* buf, size_t n) const = 0;

  const char* name() const { return name_; }
  const char* help() const { return help_; }

  virtual std::string DebugString() const = 0;

 protected:
  explicit ParameterBase(const char* name, const char* help);

  const char* const name_;
  const char* const help_;
};

template <typename T>
class Parameter : public ParameterBase {
 public:
  explicit Parameter(const char* name, const T& default_value,
                     const char* help);

  inline const T& Get() const { return value_; }
  void Set(const T& new_value) {
    value_ = new_value;
    VLOG(1) << "Parameter value updated: " << name_ << " = " << new_value;
  }

  util::Status Parse(std::string_view str) override;

  util::StatusOr<size_t> Serialize(char* buf, size_t n) const override;
  std::string DebugString() const override;

 private:
  // Do not access except through Get() and Set().
  T value_;
};

// "Container" object which iterates over all registered parameters.
// Usage: for (ParameterBase* param : AllParameters()) { ... }
struct AllParameters {
  class iterator_t {
   public:
    explicit iterator_t(int index) : index_(index) {}
    ParameterBase* operator*();
    bool operator==(const iterator_t& other) const {
      return index_ == other.index_;
    }
    bool operator!=(const iterator_t& other) const {
      return index_ != other.index_;
    }
    iterator_t& operator++() {
      index_++;
      return *this;
    }

   private:
    int index_;
  };

  iterator_t begin() const;
  iterator_t end() const;
};

template <class>
inline constexpr bool dependent_false_v = false;

template <typename T>
Parameter<T>::Parameter(const char* name, const T& default_value,
                        const char* help)
    : ParameterBase(name, help), value_(default_value) {}

template <typename T>
util::StatusOr<size_t> Parameter<T>::Serialize(char* buf, size_t n) const {
  std::string str;
  if constexpr (std::is_integral_v<T>) {
    str = absl::StrCat(Get());
  } else if constexpr (std::is_base_of_v<fix32_base_t, T>) {
    str = Get().ToDecimalString();
  } else {
    static_assert(dependent_false_v<T>,
                  "Serialize not implemented for this type");
    return util::UnimplementedError("Parameter::Serialize");
  }
  if (str.size() > n) {
    return util::ResourceExhaustedError("serialized value too large");
  }
  return str.copy(buf, n);
}

template <typename T>
util::Status Parameter<T>::Parse(std::string_view str) {
  T new_value;
  if constexpr (std::is_integral_v<T>) {
    if (!absl::SimpleAtoi(str, &new_value)) {
      return util::InvalidArgumentError("parse error");
    }
  } else if constexpr (std::is_base_of_v<fix32_base_t, T>) {
    if (!T::FromDecimalString(str, &new_value)) {
      return util::InvalidArgumentError("parse error");
    }
  } else {
    static_assert(dependent_false_v<T>, "Parse not implemented for this type");
    return util::UnimplementedError("Parameter::Parse");
  }
  Set(new_value);
  return util::OkStatus();
}

template <typename AnyPrintable>
std::string Parameter<AnyPrintable>::DebugString() const {
  return absl::StrCat(Get());
}

}  // namespace config
}  // namespace tplp

#endif  // TPLP_CONFIG_PARAMS_H_