#ifndef TPLP_CONFIG_FLAGS_H_
#define TPLP_CONFIG_FLAGS_H_

#include <functional>

#include "picolog/status.h"
#include "picolog/statusor.h"

// Declares a persistent flag. It contains a default value until
// Load() or LoadAllFlags() is used.
#define TPLP_FLAG(Type, name, default_value, help) \
  extern ::tplp::config::Flag<Type> FLAGS_##name;  \
  namespace tplp {}                                \
  tplp::config::Flag<Type> FLAGS_##name { #name, default_value, help }

namespace tplp {
namespace config {

class FlagBase {
 public:
  FlagBase(const FlagBase&) = delete;
  FlagBase& operator=(const FlagBase&) = delete;
  virtual ~FlagBase();

  // Save this flag's current value to the filesystem.
  util::Status Save() const;
  // Loads this flag's value from the filesystem, replacing the current value.
  util::Status Load();

  // Sets this flag's value from a string representation, which should have been
  // previously generated by Serialize().
  virtual util::Status Parse(std::string_view str) = 0;

  // Writes a string representation of this flag's value into the given buffer.
  // Returns the number of bytes written, which shall be at most `n`.
  virtual util::StatusOr<size_t> Serialize(char* buf, size_t n) const = 0;

  const char* name() const { return name_; }
  const char* help() const { return help_; }
  const char* file_path() const { return file_path_.c_str(); }

 protected:
  explicit FlagBase(const char* name, const char* help);

  const char* const name_;
  const char* const help_;
  const std::string file_path_;
};

template <typename T>
class Flag : public FlagBase {
 public:
  explicit Flag(const char* name, const T& default_value, const char* help);

  const T& Get() const { return value_; }
  void Set(const T& new_value) { value_ = new_value; }

  util::Status Parse(std::string_view str) override;
  util::StatusOr<size_t> Serialize(char* buf, size_t n) const override;

 private:
  T value_;
};

// "Container" object which iterates over all registered flags.
// Usage: for (FlagBase* flag : AllFlags()) { ... }
struct AllFlags {
  class iterator_t {
   public:
    explicit iterator_t(int index) : index_(index) {}
    FlagBase* operator*();
    bool operator==(const iterator_t& other) const {
      return index_ == other.index_;
    }
    bool operator!=(const iterator_t& other) const {
      return index_ != other.index_;
    }
    iterator_t& operator++() {
      index_++;
      return *this;
    }

   private:
    int index_;
  };

  iterator_t begin() const;
  iterator_t end() const;
};

// Saves all flags to the filesystem with their current values.
util::Status SaveAllFlags();
// Loads all flag values from the filesystem, replacing their current values.
util::Status LoadAllFlags();

}  // namespace config
}  // namespace tplp

#endif  // TPLP_CONFIG_FLAGS_H_